---
title: "TESFAM analysis"
author: "Laura de la Fuente, Denise Naniche, Joe Brew"
date: "June 9, 2016"
output:
  html_document:
    toc: true
    toc_float: true
    theme: yeti
---

```{r setup, include=FALSE}
# Basic knitr options
library(knitr)
opts_chunk$set(comment = NA, 
               echo = FALSE, 
               warning = FALSE, 
               message = FALSE, 
               error = FALSE, 
               cache = FALSE)
```


```{r}
library(foreign)
library(readstata13)
library(dplyr)
library(readr)
library(sp)
library(raster)
library(leaflet)
library(ggplot2)
library(rgeos)
library(maptools)
library(plotly)
library(ggthemes)
library(rasterVis)
library(rgdal)
library(readxl)
options(scipen = 999)
# Alternative unidades sanitarias (sent 2016-10-05)
us <- readxl::read_excel('coordenadas_utm.xlsx')
names(us) <- c('unidad_sanitaria',
               'location')

# Create x and y
us$x <- us$y <- NA
us$x <- unlist(lapply(strsplit(us$location, split = '/'), function(x){x[1]}))
us$y <- unlist(lapply(strsplit(us$location, split = '/'), function(x){x[2]}))
us$x <- as.numeric(us$x)
us$y <- as.numeric(us$y)

# Create a UTM x and y
us$utm_x <- us$x
us$utm_y <- us$y

# Make spatial 
coordinates(us) <- ~x+y
# Assing projection
proj4string(us) <- CRS("+proj=utm +zone=36 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs")
# Convert to lat/lng
us <- spTransform(us,
              CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +towgs84=0,0,0"))

# Extract the coordinates
ll <- coordinates(us)
# Add back into the original dataframe
us$lng <- ll[,1]
us$lat <- ll[,2]
unidades_sanitarias <- us


# Read in tesfam
tesfam <- read.dta13('TESFAM_variables_selecion_02.dta')
# tesfam <- read.dta13('joined_with_clinical_wf_1123_CLEAN_use05092016finalnonames_v12.dta')

# Read in coords
coords <- read_csv('Coordenadas.csv')
coords <- coords[!duplicated(coords$Family_id),]

# Join tesfam and coords
tesfam <- left_join(x = tesfam,
                    y = coords,
                    by = c('familynum' = 'Family_id')) %>%
  # filter(!duplicated(familynum)) %>%
  mutate(lon = LongUTM,
         lat = LatUTM,
         x = LongUTM,
         y = LatUTM)

# Make tesfam spatial
tesfam <- tesfam[!is.na(tesfam$x),]
coordinates(tesfam) <- ~x+y

# Make tesfam latlong
proj4string(tesfam) <- CRS("+proj=utm +zone=36 +south")
tesfam <- spTransform(tesfam,CRS("+proj=longlat +ellps=WGS84 +datum=WGS84"))

# Overwrite lat long
tesfam$lon <- coordinates(tesfam)[,1]
tesfam$lat <- coordinates(tesfam)[,2]

# Get distance to and name of nearest health center for each
# person in tesfam
tesfam$health_post <- NA
tesfam$distance <- NA

# Now calculate distance
distances <- 
  spDists(x = tesfam, 
        y = unidades_sanitarias,
        longlat = TRUE,
        diagonal = FALSE)

# Add distances to coordenadas dataframe
tesfam$distance <- 
  apply(distances, 1, function(x){x[which.min(x)]})

tesfam$distance_to_manhica_health_post <-
    apply(distances, 1, function(x){x[which.min(x)]})


# Get nearest center
tesfam$health_post <- 
  apply(distances,
        1, function(x){unidades_sanitarias$unidad_sanitaria[which.min(x)]})


# Get mozambique shapefile
moz <- getData('GADM', country = 'MOZ', level = 2)
moz3 <- getData('GADM', country = 'MOZ', level = 3)

# Subset to manhica
man <- moz[moz@data$NAME_2 == 'Manhiça',]
man3 <- moz3[moz3@data$NAME_2 == 'Manhiça',]

# Fortify
moz3_fortified <- fortify(moz3, region = 'NAME_3')
man3_fortified <- fortify(man3, region = 'NAME_3')


# Create a color based on testgroup
tesfam$color <-
  ifelse(tesfam$testgroup == 'HBT', 'blue',
         ifelse(tesfam$testgroup == 'VCT', 'darkorange',
                ifelse(tesfam$testgroup == "PICT", 'darkgreen',
                       NA)))

# Create a shape based on attrition
tesfam$shape <- 
  ifelse(tesfam$abandono_3mo == 1, 17,
         ifelse(tesfam$abandono_3mo == 0, 16, NA))
```

# General locations

```{r}
# Plot using base map
plot(man3, col = 'grey', border = 'white')
# People points
points(tesfam, 
       col = adjustcolor(tesfam$color, alpha.f = 0.7), 
       pch = tesfam$shape, 
       cex = 0.2)
# Health center points
points(unidades_sanitarias,
       col = adjustcolor('darkred', alpha.f = 0.7),
       pch = 1)
# Add legend
legend('topleft',
       col = c('blue', 'darkorange', 'darkgreen'),
       legend = c('HBT', 'VCT', 'PICT'),
       title = 'Testing venue',
       pch = 1)
legend('bottomright',
       pch = c(17, 16),
       legend = c('Lost to follow-up', 'Followed-up'),
       title = 'Linkage at 3 months')
legend('topright',
       pch = 1,
       col = adjustcolor('darkred', alpha.f = 0.8),
       legend = 'Health centers')
title(main = 'HIV cascade for TESFAM cohort at 3 months')


```


```{r, fig.width = 8}

cols <- c('blue', 'darkorange', 'darkgreen')
g1 <- 
  ggplot() +
coord_map() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y =lat, group = group), 
               fill = 'grey', color = 'white') +
  geom_point(data = tesfam@data %>% 
               mutate(`Follow up` = ifelse(abandono_3mo == 1, 'Lost',
                                                                'Not lost')),
              aes(x = lon, y = lat,
                  color = testgroup,
                  pch = `Follow up`),
             size = 0.5) +
  scale_color_manual(name = 'Testing venue',
                     values = cols) +
  theme_fivethirtyeight() +
  xlab('Longitude') +
  ylab('Latitude') +
  labs(title = 'Spatial distribution',
       subtitle = '3 months follow-up')

# Same as above but at 6 months

cols <- c('blue', 'darkorange', 'darkgreen')
g2 <- 
  ggplot() +
coord_map() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y =lat, group = group), 
               fill = 'grey', color = 'white') +
  geom_point(data = tesfam@data %>% 
               mutate(`Follow up` = ifelse(abandono_6mo == 1, 'Lost',
                                                                'Not lost')),
              aes(x = lon, y = lat,
                  color = testgroup,
                  pch = `Follow up`),
             size = 0.5) +
  scale_color_manual(name = 'Testing venue',
                     values = cols) +
  theme_fivethirtyeight() +
  xlab('Longitude') +
  ylab('Latitude') +
  labs(title = 'Spatial distribution',
       subtitle = '6 months follow-up')
Rmisc::multiplot(g1, g2, cols = 2)
```


# Distance to nearest health post


## Patients 


The below map shows health posts (red) and patients (blue). The shading of the blue indicates the distance to the nearest health post.  

This map is interactive. Create a box on the map to zoom in. Double-click to zoom out. Click on the legend to remove or add points. Mouse over the points to get more details.


```{r, eval = FALSE}
# Distance to health post
g <- 
  ggplot() +
coord_map() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y =lat, group = group), 
               fill = 'grey', color = 'white') +
  geom_point(data = tesfam@data %>% 
               mutate(`Follow up` = ifelse(abandono_6mo == 1, 'Lost',
                                                                'Not lost'),
                      `Distance to health post` = distance),
              aes(x = lon, y = lat,
                  color = `Distance to health post`,
                  pch = `Follow up`),
             size = 0.5) +
    geom_point(data = unidades_sanitarias@data,
               aes(x = lon, y = lat),
             color = 'red') +
  # scale_color_gradientn(colours = terrain.colors(10)) +
  theme_fivethirtyeight(base_size = 12) +
  xlab('Longitude') +
  ylab('Latitude') +
  labs(title = 'Distance to nearest health post',
       subtitle = '(The red dots are the health facilities)')
ggplotly(g)
```


## All locations

```{r}
# Raster surface of distance to nearest health post

# Create a grid
xs <- bbox(man3)[1,]
ys <- bbox(man3)[2,]
df_grid <-
  expand.grid(x = seq(min(xs), max(xs), length = 1000),
              y = seq(min(ys), max(ys), length = 1000))
df_grid$longitude <- df_grid$x
df_grid$latitude <- df_grid$y

# Make spatial
df_grid_spatial <- df_grid
coordinates(df_grid_spatial) <- ~x+y
proj4string(df_grid_spatial) <- proj4string(unidades_sanitarias)

# Get distances to nearest health post
distances <- 
  spDists(x = df_grid_spatial, 
        y = unidades_sanitarias,
        longlat = TRUE,
        diagonal = FALSE)

# Add distances to coordenadas dataframe
df_grid_spatial$distance <- 
  apply(distances, 1, function(x){x[which.min(x)]})

# Get nearest center
df_grid_spatial$health_post <- 
  apply(distances,
        1, function(x){unidades_sanitarias$unidad_sanitaria[which.min(x)]})

# Convert or raster
temp <- df_grid_spatial@data %>% arrange(longitude, latitude)
r <- rasterFromXYZ(temp[,c('longitude', 'latitude', 'distance')])

# Keep only those points in our area
proj4string(df_grid_spatial) <- proj4string(man3)
x <- over(df_grid_spatial, polygons(man3))
df_grid_small <- df_grid_spatial[!is.na(x),]

# Convert our subset data to raster
temp <- df_grid_small@data %>% arrange(longitude, latitude)
r <- rasterFromXYZ(temp[,c('longitude', 'latitude', 'distance')])
proj4string(r) <- proj4string(man3)
```

### Catchment areas

Having calculated the distances to all areas, we can examine "catchment areas". This is useful to analyze health post burden, as well as mismatching.

The below is a map of the health posts only.

```{r}
# Get a label column in unidades_sanitarias
unidades_sanitarias@data$label <-
  Hmisc::capitalize(trimws(gsub('Centro de saude de', '', unidades_sanitarias@data$unidad_sanitaria), 'both'))

library(ggrepel)
ggplot() +
  xlab('Longitude') +
  ylab('Latitude') +
  theme_bw() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y = lat, group = group),
               fill = 'grey', color = 'darkgrey') +
  geom_point(data = unidades_sanitarias@data,
             aes(x = lng, y = lat)) +
  # geom_label_repel(data = unidades_sanitarias@data,
  #            aes(x = lng, y = lat,
  #                label = unidades_sanitarias@data$label),
  #            fill = 'darkgreen',
  #            alpha = 0.5,
  #            fontface = 'bold', color = 'white',
  #            box.padding = unit(0.25, 'lines'),
  #            point.padding = unit(0.5, 'lines')) +
  coord_map()

```

The below shows the catchment breakdowns.

```{r}
catchment_data <- df_grid_small@data
catchment_data <- catchment_data %>%
  left_join(unidades_sanitarias@data %>%
              dplyr::select(label, unidad_sanitaria),
            by = c('health_post' = 'unidad_sanitaria'))
cols <- colorRampPalette(brewer.pal(9, 'Spectral'))(length(unique(df_grid_small@data$health_post)))
ggplot() +
  geom_point(data = catchment_data,
       aes(x = longitude,
           y = latitude,
           color = label)) +
  scale_colour_manual(name = 'Health post',
                    values = cols) +
  xlab('Longitude') +
  ylab('Latitude') +
  theme_bw() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y = lat, group = group),
               fill = NA, color = 'black') +
  geom_point(data = unidades_sanitarias@data,
             aes(x = lng, y = lat)) +
  coord_map()
```

We can also visual the number of study participants who fall into each catchment area:

```{r}
temp <- tesfam@data %>%
  group_by(health_post) %>%
  tally 
ggplot(data = temp,
       aes(x = health_post,
           y = n)) +
  geom_bar(stat = 'identity') +
  xlab('Health post') +
  ylab('Patients') +
  ggtitle('Catchment areas of TESFAM study participants') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Of equal (if not greater) interest are the follow-up outcomes of those patients:

```{r}
temp <- tesfam@data %>%
  group_by(health_post) %>%
  summarise(total = n(),
            lost_3 = sum(abandono_3mo),
            lost_6 = sum(abandono_6mo)) %>%
  mutate(p_3 = lost_3 / total * 100,
         p_6 = lost_6 / total * 100) %>%
  dplyr::select(-total, -lost_3, -lost_6)

# Gather into long format
temp <- temp %>%
  tidyr::gather(key, value, p_3:p_6)

# Clean up
temp$key <- gsub('p_', '', temp$key)
temp$key <- paste0('Lost at ', temp$key, ' months')
# Plot
ggplot(data = temp,
       aes(x = health_post,
           y = value,
           group = key,
           fill = key)) +
  geom_bar(stat = 'identity', 
           position = 'dodge') +
  xlab('Health post') +
  ylab('Percentage') +
  ggtitle('Percentage lost to follow-up by catchment area') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Distances

To make our work more generalizable, we can also examine the distance to the nearest health post for _all_ locations, regardless of whether a patient lives there or not. The below maps attempt to show this concept.

```{r}
# Visualize
plot(r, main = 'Kilometers to nearest health post (shading)')
plot(man3)
contour(r, add = TRUE, col = adjustcolor('black', alpha.f = 0.3),
        main = 'Kilometers to nearest health post (contour)')
# levelplot(r, contour = FALSE, par.settings = RdBuTheme,
#           main = 'Kilometers to nearest health post (shading + contour)')
vectorplot(r, par.settings = RdBuTheme(),
           lwd.arrows = 0.3,
           col.arrows = adjustcolor('black', alpha.f = 0.2),
           main = 'Kilometers to nearest health post (vector + shading)')
```


### "Acceptably close" residents

Distance to health post is a continuous variable. However, we might deem binning it or making it binary a worthy cause in the pursuit of simplicity, modeling, etc.

The below chart shows the percentage of TESFAM patients who are deemed to be "acceptably close" to a health post, as a function of how we define "acceptable".

```{r}
df <- data.frame(distance = seq(0, 15, length = 100))
df$patients <- NA
for (i in 1:nrow(df)){
  df$patients[i] <-
    length(which(tesfam$distance <= df$distance[i]))
}
df$p <- df$patients / nrow(tesfam) * 100

ggplot(data = df,
       aes(x = distance, y = p)) +
  geom_area(fill = 'darkred', alpha = 0.6) +
  xlab('Distance') +
  ylab('Percentage') +
  ggtitle('Percentage of patients "acceptably close" to health post')
```


### Person-kilometers attributable to each health post

We can calculate the total number of kilometers needed to be traveled by each TESFAM participant in order to reach the nearest health post (see below map).

```{r}
ggplot() +
  geom_polygon(data = man3_fortified,
       aes(x = long,
           y = lat,
           group = group)) +
  coord_map() +
  geom_point(data = tesfam@data,
             aes(size = distance,
                 color = health_post,
                 x = lon, 
                 y = lat),
             alpha = 0.3) +
  xlab('Longitude') +
  ylab('Latitude')
```

We can then aggregate at the health post level to get the person-kilometers attributable to each post. By the same token, we can also just get average distance for patients for each catchment area:

```{r}
temp <- tesfam@data %>%
  group_by(health_post) %>%
  summarise(total_distance = sum(distance),
            average_distance = mean(distance),
            patients = n())

ggplot(data = temp,
       aes(x = health_post,
           y = average_distance)) +
  geom_bar(stat = 'identity', fill = 'darkred', alpha = 0.6) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  xlab('Health post') +
  ylab('Average kilometers') +
  ggtitle('Average distance from post to patients for each catchment area')
```


# Population and HIV information

We do not have the _true_ spatial distribution of every HIV positive resident of Manhiça. However, we do have two key pieces of data which allow us to _estimate_ that distribution. These are:

1. HIV prevalence by age group and sex.
2. The true spatial distribution of all Manhiça residents (from the census), regardless of HIV status.

```{r}
# Manually input hiv prevalence by age / sex
hiv_prev <- 
  expand.grid(sex = c('male', 'female'),
              age = c('15-18',
                      '18-27',
                      '28-37',
                      '38-49',
                      '50-64',
                      '65+'))
hiv_prev$prevalence <-
  c(3.0,
    10,
    15.8,
    25.6,
    40.5,
    46.3,
    43,
    46,
    19.5,
    25,
    8.2,
    6.1)

```

The distribution of HIV positivity by sex and age appears as below (data provided by Denise to Joe on September 21, 2016.

```{r}
ggplot(data = hiv_prev,
       aes(x = age,
           y = prevalence,
           group = sex,
           fill = sex)) +
  geom_bar(position = 'dodge',
           stat = 'identity',
           alpha = 0.6) +
  scale_fill_manual(name = 'Sex',
                    values = c('darkblue', 'darkred')) +
  theme_tufte() +
  xlab('Age') +
  ylab('%') +
  ggtitle('HIV Prevalence by age and sex',
          'Resident of Manhiça, Mozambique')
```


## Population density

```{r}
# GET CENSUS DATA
# Manhica ----------------------------------------------------------
load('census/openhds/2016-07-15_individual.RData')
individual$dob <- as.Date(individual$dob)
individual$house_number <- substr(individual$lastName, 1, 8)
individual$name <- individual$firstName
individual$permid <- individual$lastName
individual <- individual %>%
  dplyr::select(permid, name, house_number, dob, gender)
# Read in coordinates (emailed from Charfudin)
coords <- read_csv('census/openhds/Coordenadas.csv')
names(coords) <- c('house_number', 'region', 'lat', 'lng')
coords$region <- NULL
# Combine
census_manhica <- left_join(individual,
                            coords,
                            by = 'house_number')
rm(individual, coords)

# Convert census_manhica to lat/lng
census_manhica_location <- census_manhica %>% filter(!is.na(lat) & !is.na(lng))
census_manhica_no_location <- census_manhica %>% filter(is.na(lat) | is.na(lng))
sp::coordinates(census_manhica_location) <- ~lng+lat
proj4string(census_manhica_location) <- CRS("+proj=utm +zone=36 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs")
census_manhica_location <- spTransform(census_manhica_location, CRS('+proj=longlat'))
# Extract the coordinates
ll <- coordinates(census_manhica_location)
# Add back into the original dataframe
census_manhica_location$x <- ll[,1]
census_manhica_location$y <- ll[,2]
census_manhica_location <- data.frame(census_manhica_location@data)
# change names
census_manhica_location <-
  census_manhica_location %>%
  rename(lng = x,
         lat = y)
# Combine all of manhica back together
census_manhica <-
  rbind(census_manhica_location,
        census_manhica_no_location)
rm(census_manhica_location, census_manhica_no_location)

# Expand coordinates
census_manhica$longitude <-
  census_manhica$x <-
  census_manhica$lon <-
  census_manhica$lng
census_manhica$latitude <-
  census_manhica$y <-
  census_manhica$lat
census_manhica$geo <- 'Manhiça'
census_manhica <-
  census_manhica %>%
  dplyr::select(permid,
                dob,
                gender,
                name,
                house_number,
                lng,
                longitude,
                x,
                lon,
                lat,
                latitude,
                y,
                geo)
# Recode gender
census_manhica$gender <-
  ifelse(census_manhica$gender == 'F',
         'female',
         ifelse(census_manhica$gender == 'M',
                'male', 
                NA))
census <- census_manhica
census_manhica <- NULL
```

The distribution of Manhiça residents, per the census, is as follows:

```{r}

ggplot() +
  coord_map() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y =lat, group = group), 
               fill = 'grey', color = 'white') +
  # Add the census
  geom_point(data = census,
                 aes(x = lng,
                     y = lat),
             alpha = 0.6,
             pch = '.') +
  theme(axis.title = element_blank(), 
        text = element_text(size = 12)) +
  xlab('Longitude') +
  ylab('Latitude') +
  theme_map()

```

Given that a scattering of points is difficult to visualize in high density (hundreds of thousands of residents), we can also take a look at a smoothed contour of resident locations.

```{r}
# Smoothed contours
ggplot() +
  coord_map() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y =lat, group = group), 
               fill = 'grey', color = 'white') +
  # Add the census
  geom_density2d() +
  stat_density2d(data = census,
                 aes(x = lng,
                     y = lat,
                     fill = ..level..,
                     alpha = ..level..),
                 size = 2,
                 bins = 100,
                 geom = 'polygon') +
  scale_fill_gradient(low = "green", high = "red", name = '') +
  scale_alpha(range = c(0.00, 1),
              guide = FALSE) +
  theme_map() +
    theme(legend.position = "none", 
        axis.title = element_blank(), 
        text = element_text(size = 12)) 
# xlab('Longitude') +
  # ylab('Latitude')
  
```

An alternative is to get the number of residents per district:

```{r}
# Get nearest health center for everyone in census
census <- census %>% 
  filter(!duplicated(permid))
census_spatial <- census
census_spatial <- census_spatial %>% filter(!is.na(lng), !is.na(lat))
coordinates(census_spatial) <- ~x+y
proj4string(census_spatial) <- proj4string(unidades_sanitarias)

# Get distances to nearest
distances <- spDists(x = census_spatial,
                       y = unidades_sanitarias,
                        longlat = TRUE)

# Get minimum distance
census_spatial$distance <- apply(distances,
                                 1,
                                 min,
                                 na.rm = TRUE)

# Get closest center
census_spatial$health_post <-
  apply(distances,
        1,
        function(x){
          unidades_sanitarias$unidad_sanitaria[which.min(x)]
        })

# Get distance to manhica
manhica_index <- 7 #unidades_sanitarias$unidad_sanitaria
census_spatial$distance_to_manhica_health_post <- distances[,manhica_index]

# Get prevalence for each spatial point too
census_spatial$prevalence <- extract(r, census_spatial)
# Join back to census
census <-
  census %>% 
  left_join(census_spatial@data)

# Project likelihood of every person of having hiv
hiv_likelihood <- 
  census %>%
  dplyr::select(lng,
                lat,
                dob,
                gender) %>%
  rename(sex = gender) %>%
  mutate(years = as.numeric(as.Date('2016-10-01') - 
           census$dob) / 365.25) %>%
  mutate(age = ifelse(years < 15, NA,
                      ifelse(years >= 15 &
                               years < 18,
                             '15-18',
                             ifelse(years >= 18 &
                                      years < 27,
                                    '18-27',
                                    ifelse(years >= 27 &
                                             years < 37,
                                           '28-37',
                                           ifelse(years >= 37 &
                                                    years < 49,
                                                  '38-49',
                                                  ifelse(years >=49 &
                                                           years < 64,
                                                         '50-64',
                                                         ifelse(years >= 64,
                                                                '65+', NA)))))))) %>%
  dplyr::select(lng,
                lat,
                sex, 
                age)

# Join to prevalence
hiv_likelihood <-
  left_join(hiv_likelihood,
            hiv_prev)
# Make spatial
hiv_likelihood <- hiv_likelihood %>% filter(!is.na(lng),
                                            !is.na(lat))
hiv_likelihood_spatial <- hiv_likelihood
hiv_likelihood_spatial$x <- hiv_likelihood$lng
hiv_likelihood_spatial$y <- hiv_likelihood$lat
coordinates(hiv_likelihood_spatial) <- ~x+y
proj4string(hiv_likelihood_spatial) <- proj4string(man)

# ALSO JOIN FOR TESFAM DATA
tesfam@data <-
  tesfam@data %>%
  mutate(permid = perm_id) %>%
  left_join(census %>%
  dplyr::select(dob,
                gender,
                permid) %>%
    filter(!duplicated(permid)) %>%
  rename(sex = gender) %>%
  mutate(years = as.numeric(as.Date('2016-10-01') - 
           dob) / 365.25) %>%
  mutate(age = ifelse(years < 15, NA,
                      ifelse(years >= 15 &
                               years < 18,
                             '15-18',
                             ifelse(years >= 18 &
                                      years < 27,
                                    '18-27',
                                    ifelse(years >= 27 &
                                             years < 37,
                                           '28-37',
                                           ifelse(years >= 37 &
                                                    years < 49,
                                                  '38-49',
                                                  ifelse(years >=49 &
                                                           years < 64,
                                                         '50-64',
                                                         ifelse(years >= 64,
                                                                '65+', NA)))))))) %>%
  dplyr::select(sex, 
                age,
                permid) %>%
    left_join(hiv_prev))
```

```{r}
x <- over(hiv_likelihood_spatial, polygons(man3))
districts <- man3$NAME_3
hiv_likelihood$district <- districts[x]
x <- hiv_likelihood %>%
  group_by(district) %>%
  summarise(n = n(),
            estimated_prevalence = mean(prevalence, na.rm = TRUE))
```

## HIV prevalence over space

Now we can combine our two data sources to estimate two values:

1. The prevalence of HIV by location (ie, the likelihood of being HIV positive, given the demographic make-up of a location)

2. The proximity of any location to HIV-positive residents.

This approach allows us to estimate the prevalence by district:

```{r}
x <- x %>% arrange(estimated_prevalence)
x <- x %>% filter(!is.na(district))
x$district <- factor(x$district, levels = x$district)
ggplot(data = x,
       aes(x = district,
           y = estimated_prevalence)) +
  geom_bar(stat = 'identity',
           alpha = 0.6) +
  theme_economist() +
  theme(axis.text.x = element_text(angle = 90)) +
  xlab('') +
  ylab('Estimated prevalence') +
  ggtitle('Estimated HIV prevalence by District') +
  geom_label(aes(label = paste0(round(estimated_prevalence, digits = 2), '%')))  +
  ylim(0, max(x$estimated_prevalence) + 3)
```

Which we can also visualize spatially:

```{r}
y <- man3_fortified %>%
  left_join(x,
            by = c('id' = 'district')) %>%
  rename(`%` = estimated_prevalence)
ggplot(y,
       aes(x = long, y = lat)) +
  geom_polygon(aes(group = id,
                   fill = `%`)) +
  coord_map() +
    xlab('Longitude') +
  ylab('Latitude') +
  ggtitle('Estimated prevalence of HIV') +
  theme(panel.background = element_rect(fill = 'white', 
                                        colour = 'white'),
        panel.grid.major = element_line(colour = "white"))
```

```{r}

# Create a gridded dataframe with values 
# for the entire range (bbox) of man
df_grid <- expand.grid(lng = seq(bbox(man)[1,1],
                                 bbox(man)[1,2],
                                 by = 0.01),
                       lat = seq(bbox(man)[2,1],
                                 bbox(man)[2,2],
                                 by = 0.01),
                       hiv = NA,
                       hiv_score = NA,
                       within_10 = NA,
                       within_05 = NA,
                       within_01 = NA,
                       color = NA)
df_grid$latitude <- df_grid$lat
df_grid$longitude <- df_grid$lng
coordinates(df_grid) <- ~longitude+latitude

# Go through each row of df_grid, getting the 
# weighted mean hiv score for that point
# and putting a color into df_grid
if('df_grid.RData' %in% dir()){
  load('df_grid.RData')
} else {
  the_rows <- nrow(df_grid)
  for (i in 1:nrow(df_grid)){
    message(paste0(i, ' of ', the_rows))
  # Get distance from every point in cmagvec
  distances <- spDistsN1(pts = hiv_likelihood_spatial,
                        pt = df_grid[i,],
                        longlat = TRUE)
  # Define which are acceptably close
  close_enough <- which(distances <= 50)
  # Get an hiv score
  hiv <- stats::weighted.mean(x = hiv_likelihood_spatial$prevalence[close_enough],
                       w = (1 / distances[close_enough]) ^2,
                       na.rm = TRUE)
  # Assign hiv to the dataframe
  df_grid$hiv[i] <- hiv
  # Get the hiv score on a 0-1000 scale
  # and add 1 so that it's on a 1-1001 scale (for coloring)
  hiv_score <- round(hiv * 1000) + 1
  df_grid$hiv_score[i] <- hiv_score
  
  # Get likely number of hiv positives within 10 km
  within_10 <- (mean(hiv_likelihood_spatial$prevalence[distances <= 10], na.rm = TRUE)/100) *
    length(which(distances <= 10))
  df_grid$within_10[i] <- ifelse(is.na(within_10),
                                 0,
                                 within_10)
  
    # Get likely number of hiv positives within 5 km
  within_05 <- (mean(hiv_likelihood_spatial$prevalence[distances <= 05], na.rm = TRUE)/100) *
    length(which(distances <= 05))
  df_grid$within_05[i] <- ifelse(is.na(within_05),
                                 0,
                                 within_05)
  
      # Get likely number of hiv positives within 1 km
  within_01 <- (mean(hiv_likelihood_spatial$prevalence[distances <= 01], na.rm = TRUE)/100) *
    length(which(distances <= 01))
  df_grid$within_01[i] <- ifelse(is.na(within_01),
                                 0,
                                 within_01)
    
}
save('df_grid', file = 'df_grid.RData')

}

# Fix up the hiv score
df_grid$hiv_score <-
  df_grid$hiv_score -
  min(df_grid$hiv_score, na.rm = TRUE)

# Create a n length color vector
color_vector <-
  colorRampPalette(c('red', 'yellow', 'green'))(max(df_grid$hiv_score, na.rm = TRUE) +1)

# If there are no nearby obs, just make white
# otherwise, give it a color from the palette
df_grid$color <- 
  ifelse(is.na(df_grid$hiv_score),
         'white',
         color_vector[df_grid$hiv_score])

```

```{r}
# Convert df_grid to raster
temp <- df_grid@data %>% arrange(lng, lat)
r <- rasterFromXYZ(temp[, c('lng', 'lat', 'hiv')])
# Make only for district
proj4string(df_grid) <- proj4string(man)
x <- over(df_grid, polygons(man))
df_grid_small <- df_grid[!is.na(x),]
temp <- df_grid_small@data %>% arrange(lng, lat)
r <- rasterFromXYZ(temp[, c('lng', 'lat', 'hiv')], crs = proj4string(man))
plot(r)
# levelplot(r, 
#           # zscaleLog=TRUE,
#           # par.settings = RdBuTheme,
#           contour=FALSE)
contour(r, add = TRUE,
        col = adjustcolor('black', alpha.f = 0.3))
title(main = 'Estimated HIV prevalence')
# vectorplot(r, par.settings=RdBuTheme())
```

In addition to examining the prevalence (which is independent of population density), we can also examine the number of estimated HIV positive cases within a certain proximity of each location, thereby taking into account both prevalence and density.

```{r}
temp <- df_grid_small@data %>% arrange(lng, lat)
r <- rasterFromXYZ(temp[, c('lng', 'lat', 'within_10')], crs = proj4string(man))
plot(r)
contour(r, add = TRUE,
        col = adjustcolor('black', alpha.f = 0.3))
title(main = 'Estimated HIV positive residents within 10 kilometers')
```

We can do the same for 5 kilometers.


```{r}
temp <- df_grid_small@data %>% arrange(lng, lat)
r <- rasterFromXYZ(temp[, c('lng', 'lat', 'within_05')], crs = proj4string(man))
plot(r)
contour(r, add = TRUE,
        col = adjustcolor('black', alpha.f = 0.3))
title(main = 'Estimated HIV positive residents within 5 kilometers')
```

Or 1 kilometer:


```{r}
temp <- df_grid_small@data %>% arrange(lng, lat)
r <- rasterFromXYZ(temp[, c('lng', 'lat', 'within_01')], crs = proj4string(man))
plot(r)
contour(r, add = TRUE,
        col = adjustcolor('black', alpha.f = 0.3))
title(main = 'Estimated HIV positive residents within 1 kilometer')
```



```{r, eval = FALSE}
ggplot(man3_fortified,
       aes(x = long, y = lat)) +
  geom_polygon(aes(group = id), fill = 'black') +
  geom_point(data = temp,
             aes(x = lng, y = lat, col = hiv),
             size = 1) +
    geom_polygon(aes(group = id), fill = NA, color = 'black', alpha = 0.5) +
  coord_map() +
    xlab('Longitude') +
  ylab('Latitude') +
  ggtitle('hiv coverage (census)') +
  theme(panel.background = element_rect(fill = 'white', 
                                        colour = 'white'),
        panel.grid.major = element_line(colour = "white")) +
  scale_color_gradient2(low = 'white', high = 'blue')
```

Rather than analyzing over all space, we can focus only on health centers. Specifically, we may want to examine the likely number of HIV-positive residents within n meters of each health post (so as to gauge patient load).

```{r}
distances <- seq(0, 50, length = 101)
places <- sort(unique(unidades_sanitarias$unidad_sanitaria))
if('hiv_prev_by_us.RData' %in% dir()){
  load('hiv_prev_by_us.RData')
} else {
    x <- expand.grid(distance = distances,
                   place = places)
  x$people <- x$hiv <- NA
  # Loop through each combination of distance and unidad
  # sanitaria to get number of HIV positive people within n kilometers
  for (i in 1:nrow(x)){
    this_us <- x$place[i]
    this_distance <- x$distance[i]
    if(this_distance == 0){
      x$hiv[i] <- x$people[i] <- 0
    } else {
    sub_us <- us[us@data$unidad_sanitaria == this_us,]
      # Get distance from every point in cmagvec
    distances <- spDistsN1(pts = hiv_likelihood_spatial,
                          pt = sub_us,
                          longlat = TRUE)
    # Define which are acceptably close
    close_enough <- which(distances <= this_distance)
    # Get total number of people
    x$people[i] <- length(close_enough)
    # Get average
    x$hiv[i] <- 
      (mean(hiv_likelihood_spatial$prevalence[close_enough], na.rm = TRUE) / 100) *
      x$people[i]
    }
    message(i)
  }

save(x, file = 'hiv_prev_by_us.RData')
}

cols <- colorRampPalette(brewer.pal(n = 9,
                                    name = 'Spectral'))(length(unique(x$place)))
ggplot(data = x %>%
         mutate(place = gsub('Centro de saude de ', 
                             '',
                             place)),
       aes(x = distance,
           y = hiv)) +
  geom_line(aes(color = place)) +
  scale_color_manual(name = 'Health center',
                     values = cols) +
  theme_tufte() +
  xlab('Kilometers') +
  ylab('Number of HIV positive residents') +
  ggtitle('HIV positive residents and proximity to health centers')

```

Alternatively, we can focus exclusively on Manhiça.

```{r}

cols <- colorRampPalette(brewer.pal(n = 9,
                                    name = 'Spectral'))(length(unique(x$place)))
ggplot(data = x %>%
         mutate(place = gsub('Centro de saude de ', 
                             '',
                             place)) %>%
         filter(place == 'manhica sede'),
       aes(x = distance,
           y = hiv)) +
  geom_line() +
  theme_tufte() +
  xlab('Kilometers') +
  ylab('Number of HIV positive residents') +
  ggtitle('HIV positive residents and proximity to health centers',
       'Manhiça only') +
  xlim(0, 60)

```

## Study participants and nearby prevalence

We can visualize our HIV prevalence distribution ALONG WITH our study participant locations.

```{r}
temp <- df_grid@data %>% arrange(lng, lat)
r <- rasterFromXYZ(temp[, c('lng', 'lat', 'hiv')])
# Make only for district
proj4string(df_grid) <- proj4string(man)
x <- over(df_grid, polygons(man))
df_grid_small <- df_grid[!is.na(x),]
temp <- df_grid_small@data %>% arrange(lng, lat)
r <- rasterFromXYZ(temp[, c('lng', 'lat', 'hiv')], crs = proj4string(man))

plot(r)
points(tesfam,
       pch = '.',
       col = adjustcolor('black', alpha.f = 0.3),
       cex = 2)
title(main = 'Estimated HIV prevalence and TESFAM participants')
```

Well, that's confusing. What we really want to know is if our study participants are in areas that are more or less likely than the general population to be affected by HIV. Right?

```{r}
# Convert df_grid to raster
temp <- df_grid@data %>% arrange(lng, lat)
r <- rasterFromXYZ(temp[, c('lng', 'lat', 'hiv')])
# Make only for district
proj4string(df_grid) <- proj4string(man)
x <- over(df_grid, polygons(man))
df_grid_small <- df_grid[!is.na(x),]
temp <- df_grid_small@data %>% arrange(lng, lat)
r <- rasterFromXYZ(temp[, c('lng', 'lat', 'hiv')], crs = proj4string(man))

x <- extract(x = r,
             y = tesfam)
tesfam@data$prevalence <- x
z <- data.frame(
  src = 'participants',
  x = x
)
z2 <- data.frame(
  src = 'all',
  x = jitter(y$`%`, factor = 150)
)
z <- rbind(z, z2)

ggplot(data = z,
       aes(x = x,
           group = src,
           fill = src)) +
  geom_density(alpha = 0.6) +
  theme_economist() +
  scale_fill_manual(name = '',
                    values = c('darkblue',
                             'darkred')) +
  ggtitle('Distribution of prevalence: study participants vs. at-large') +
  xlab('%') +
  ylab('Density')
```

The answer to that question is yes. The HIV prevalence in Manhiça is around `r mean(y[,"%"])`, whereas study participants live in areas with an average prevalence of `r mean(x)`.

## Summary statistics by catchment area

```{r}

# Get prevalence for each spatial point too
census_spatial$prevalence <- extract(r, census_spatial)
# Join back to census
census <-
  census %>% 
  left_join(census_spatial@data)


load('hiv_prev_by_us.RData') # becomes x, created above
x <- x %>% 
  filter(distance %in% c(1, 5, 10))
# Get within catchment area
y <- census %>%
  group_by(distance = 'Catchment area',
           place = health_post) %>%
  summarise(hiv = sum(prevalence/100, na.rm = TRUE),
            people = n()) %>%
  ungroup
x <- rbind(x,y) %>%
  arrange(distance)
x$place <- 
  gsub('Centro de saude de ',
       '',
       x$place)

```

What follow are some simple summary statistics by health post / catchment area.

```{r}
cols <- colorRampPalette(brewer.pal(n = 9,
                                    name = 'Spectral'))(length(unique(x$distance)))
ggplot(data = x,
       aes(x = place,
           y = people,
           group = distance,
           fill = distance)) +
  theme_economist() +
  geom_bar(stat = 'identity',
           position = 'dodge') +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_fill_manual(name = 'Distance / kilometers',
                    values = cols) +
  ylab('Total residents') +
  xlab('Unidad sanitaria') +
  ggtitle('Total resident load by health center')

ggplot(data = x,
       aes(x = place,
           y = hiv,
           group = distance,
           fill = distance)) +
  theme_economist() +
  geom_bar(stat = 'identity',
           position = 'dodge') +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_fill_manual(name = 'Distance / kilometers',
                    values = cols) +
  ylab('Residents with HIV') +
  xlab('Unidad sanitaria') +
  ggtitle('HIV load by health center')
```

Alternatively, the below table has full details on the number of people and HIV positive people pertaining to each unidad sanitaria. Distance in numbers refers to radial kilometers; catchment area is self-explanatory.

```{r}
DT::datatable(x %>% arrange(place) %>%
                mutate(hiv = round(hiv)))
```

### Statistical significance 

In examining the question of a _correct_ distribution by health center, we can use simple Chi-squared tests to examine the likelihood that the distribution of residents by health center can be attributed to chance.

```{r}
the_test <- chisq.test(x = x$people[x$distance == 'Catchment area'])
print(the_test)
```

We can also examine the likelihood that the distribution of HIV POSITIVE residents by health center can be attributed to chance.

```{r}
the_test <- chisq.test(x = x$hiv[x$distance == 'Catchment area'])
print(the_test)
```

In both of the above cases, we reject the null hypothesis (ie, the differences in number of patients and in number of HIV positive patients IS statistically significant).

A perhaps more useful test is to see whether the prevalence is different. We can do this through simple logistic regression.

```{r}
model_data <- x[x$distance == 'Catchment area',] %>%
  filter(!is.na(place)) %>%
  mutate(hiv = round(hiv))
model_data$place <- trimws(model_data$place)
model_data$place <- factor(model_data$place, levels = unique(c('manhica sede',
                                                               model_data$place)))
fit <- glm(cbind(hiv, people) ~ place,
           data = model_data,
           family = binomial('logit'))
ors <- exp(cbind(OR = coef(fit), confint(fit))) %>%
  data.frame
ors$health_post <- row.names(ors)
row.names(ors) <- NULL
ors$health_post <- gsub('place', '', ors$health_post)
ors <- ors %>% filter(health_post != '(Intercept)')
names(ors)[2:3] <- c('lwr', 'upr')
print(ors)

```

Testing in this way, we find that (relative to the baseline of `r as.character(levels(model_data$place)[1])`), there are some significant differences in the prevalence of estimated HIV. See above table or below chart.

```{r}
ggplot(data = ors,
       aes(x = health_post,
           y = OR)) +
  geom_point(alpha = 0.6) +
  geom_linerange(aes(ymax = upr,
                     ymin = lwr),
                 alpha = 0.6) +
  geom_hline(yintercept = 1, lty = 3) +
  xlab('Health post') +
  ylab('Odds of HIV') +
  theme_tufte() +
  theme(axis.text.x = element_text(angle = 90)) +
  ggtitle('Statistically significant differences in estimated odds of HIV by location')

```

```{r}
# Generate distances for elisa
x <- tesfam@data %>%
  dplyr::select(ssid,
                perm_id,
                health_post,
                distance,
                distance_to_manhica_health_post)
write_csv(x, '~/Desktop/distances_for_elisa.csv')
```

# Analysis

## Does distance to center matter?

Association between distance to center and likelihood of being lost to follow-up. We model the likelihood of being lost to followup at 6 months, only among those who are in Manhiça's catchment area, as a function of distance to the Manhiça health post. In other words, this is entirely _unadjusted_ for all other factors.

```{r}
# Logistic regression model
fit <- glm(abandono_6mo ~ distance_to_manhica_health_post, 
           data = tesfam@data %>%
             filter(health_post == 'Centro de saude de manhica sede'),
           family = binomial('logit'))
ors <- exp(cbind(OR = coef(fit), confint(fit))) %>%
  data.frame
```

Using a simple logistic regression model, we estimate that for every 1 kilometer further from a health post, the odds of being lost to follow-up at 6 months increases by `r round((ors$OR[2] - 1) * 100, digits = 2)`% (OR of `r ors$OR[2]`, 95% confidence interval of `r ors$X2.5..[2]` to `r ors$X97.5..[2]`). Our fitted model can be visualized like this.

```{r}

fake <- data.frame(distance_to_manhica_health_post = seq(0, 25, length = 100))
predictions <- predict(fit, fake, type = 'link', se = TRUE)
fake$predicted <- plogis(predictions$fit)
fake$lwr <- plogis(predictions$fit - (1.96 * predictions$se.fit))
fake$upr <- plogis(predictions$fit + (1.96 * predictions$se.fit))

# Gather
fake_gathered <- tidyr::gather(data = fake,
                               key, 
                               value, 
                               predicted:upr)

ggplot(data = fake) +
  geom_linerange(aes(x = distance_to_manhica_health_post,
                     ymax = upr,
                     ymin = lwr),
                 alpha = 0.6) +
  geom_line(aes(x = distance_to_manhica_health_post, y = predicted),
            color = 'red') +
  labs(title = 'Distance matters?',
       subtitle = 'Association of distance to health post and getting lost') +
  theme_economist() +
    xlab('Kilometers to health post') +
  ylab('Likelihood of being lost to follow-up at 6 mo') 

```

## Does distance to Manhiça matter?

## Does nearby prevalence matter?

Association between nearby prevalence and likelihood of being lost to follow-up. 

```{r}
# Logistic regression model
fit <- glm(abandono_6mo ~ prevalence, 
           data = tesfam@data,
           family = binomial('logit'))
ors <- exp(cbind(OR = coef(fit), confint(fit))) %>%
  data.frame
```

Using a simple logistic regression model, we estimate that for every 1 % increase in nearby prevalence, the odds of being lost to follow-up at 6 months increases by `r round((ors$OR[2] - 1) * 100, digits = 2)`% (OR of `r ors$OR[2]`, 95% confidence interval of `r ors$X2.5..[2]` to `r ors$X97.5..[2]`). Our fitted model can be visualized like this.

```{r}

fake <- data.frame(prevalence = seq(0, 50, length = 100))
predictions <- predict(fit, fake, type = 'link', se = TRUE)
fake$predicted <- plogis(predictions$fit)
fake$lwr <- plogis(predictions$fit - (1.96 * predictions$se.fit))
fake$upr <- plogis(predictions$fit + (1.96 * predictions$se.fit))

# Gather
fake_gathered <- tidyr::gather(data = fake,
                               key, 
                               value, 
                               predicted:upr)

ggplot(data = fake) +
  geom_linerange(aes(x = prevalence,
                     ymax = upr,
                     ymin = lwr),
                 alpha = 0.6) +
  geom_line(aes(x = prevalence, y = predicted),
            color = 'red') +
  labs(title = 'Prevalence matters?',
       subtitle = 'Association prevalence and getting lost to follow-up') +
  theme_economist() +
    xlab('Nearby estimated prevalence') +
  ylab('Likelihood of being lost to follow-up at 6 mo') 
```

# Appendix

## Fancy interactive satellite map

The blue markers are health posts.

```{r}
library(leaflet)
library(RColorBrewer)

colspal <- brewer.pal(3, 'Spectral')
cols <- colspal[as.numeric(factor(tesfam$testgroup))]

# Subset data to only include those that got lost
lost <- data.frame(tesfam) %>% filter(abandono_3mo == 1)
not_lost <- data.frame(tesfam) %>% filter(abandono_3mo == 0)

# Get colors
lost_cols <- colspal[as.numeric(factor(lost$testgroup))]
not_lost_cols <- colspal[as.numeric(factor(not_lost$testgroup))]


leaflet() %>%
  # addProviderTiles('Stamen.Watercolor') %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addCircleMarkers(lng = lost$lon,
                  lat = lost$lat,
                  color = lost_cols,
                  fillColor = lost_cols,
                  radius = 2.5,
                  opacity = 0,
                  fillOpacity = 0.5,
                  popup = paste0('Study number: ', lost$ssid, '\n',
                                 'Group: ', lost$testgroup, '\n',
                                 '3 month followup: ',
                                 ifelse(lost$abandono_3mo == 1, 'Lost',
                                        'Not lost'))) %>%
      addLegend("bottomright", colors= colspal,
                labels=c('HBT', 'VCT', 'PICT'), title="Study arm") %>%
    addCircleMarkers(lng = not_lost$lon,
                  lat = not_lost$lat,
                  color = not_lost_cols,
                  fillColor = not_lost_cols,
                  radius = 5,
                  opacity = 0,
                  fillOpacity = 1,
                  popup = paste0('Study number: ', not_lost$ssid, '\n',
                                 'Group: ', not_lost$testgroup, '\n',
                                 '3 month followup: ', 
                                 ifelse(not_lost$abandono_3mo == 1, 'Lost',
                                        'Not not_lost'))) %>% #,
                  # clusterOptions = markerClusterOptions()) 
  addMarkers(lng = unidades_sanitarias@data$lng,
             lat = unidades_sanitarias@data$lat,
             popup = unidades_sanitarias@data$name)
```


## Fancy interactive road map

The blue markers are health posts.

```{r}
library(leaflet)
library(RColorBrewer)
colspal <- brewer.pal(3, 'Spectral')
cols <- colspal[as.numeric(factor(tesfam$testgroup))]

# Subset data to only include those that got lost
lost <- data.frame(tesfam) %>% filter(abandono_3mo == 1)
not_lost <- data.frame(tesfam) %>% filter(abandono_3mo == 0)

# Get colors
lost_cols <- colspal[as.numeric(factor(lost$testgroup))]
not_lost_cols <- colspal[as.numeric(factor(not_lost$testgroup))]


leaflet() %>%
  # addProviderTiles('Stamen.Watercolor') %>%
  # addProviderTiles("Esri.WorldImagery") %>%
  addProviderTiles('OpenStreetMap.BlackAndWhite') %>%
  addCircleMarkers(lng = lost$lon,
                  lat = lost$lat,
                  color = lost_cols,
                  fillColor = lost_cols,
                  radius = 2.5,
                  opacity = 0,
                  fillOpacity = 0.5,
                  popup = paste0('Study number: ', lost$ssid, '\n',
                                 'Group: ', lost$testgroup, '\n',
                                 '3 month followup: ',
                                 ifelse(lost$abandono_3mo == 1, 'Lost',
                                        'Not lost'))) %>%
      addLegend("bottomright", colors= colspal,
                labels=c('HBT', 'VCT', 'PICT'), title="Study arm") %>%
    addCircleMarkers(lng = not_lost$lon,
                  lat = not_lost$lat,
                  color = not_lost_cols,
                  fillColor = not_lost_cols,
                  radius = 5,
                  opacity = 0,
                  fillOpacity = 1,
                  popup = paste0('Study number: ', not_lost$ssid, '\n',
                                 'Group: ', not_lost$testgroup, '\n',
                                 '3 month followup: ', 
                                 ifelse(not_lost$abandono_3mo == 1, 'Lost',
                                        'Not not_lost'))) %>%#,
                  # clusterOptions = markerClusterOptions()) 
    addMarkers(lng = unidades_sanitarias@data$lng,
             lat = unidades_sanitarias@data$lat,
             popup = unidades_sanitarias@data$name)

```


