---
title: "TESFAM analysis"
author: "Laura de la Fuente, Denise Naniche, Joe Brew"
date: "June 9, 2016"
output:
  html_document:
    toc: true
    toc_float: true
    theme: yeti
---

```{r setup, include=FALSE}
# Basic knitr options
library(knitr)
opts_chunk$set(comment = NA, 
               echo = FALSE, 
               warning = FALSE, 
               message = FALSE, 
               error = FALSE, 
               cache = FALSE)
```




```{r}
library(foreign)
library(readstata13)
library(dplyr)
library(readr)
library(sp)
library(raster)
library(leaflet)
library(ggplot2)
library(rgeos)
library(maptools)
library(plotly)
library(ggthemes)
library(rasterVis)
library(rgdal)
library(readxl)

# # Manually enter in the location of health posts
# unidades_sanitarias <- 
#   data.frame(name = c('Xinavane',
#                       '3 de fevereiro',
#                       'Iha Josina',
#                       'Mirrona',
#                       'Taninga',
#                       'Manxiane',
#                       'Palmeiras',
#                       'Chibucutsu'),
#              lat = c("25'2'815",
#                      "25'9'43",
#                      "25'5'617",
#                      "25'13'48",
#                      "25'10'74",
#                      "25'18'55",
#                      "25'15'73",
#                      "25'17'21"),
#              lng = c("32'48'308",
#                      "32'48'033",
#                      "32'55'035",
#                      "32'39'86",
#                      "32'51'12",
#                      "32'49'97",
#                      "32'51'87",
#                      "32'44'41"),
#              stringsAsFactors = FALSE)

# # Read in spreadsheet (manually made by me, based on emails
# # from Charfudin / Aura) of unidades_sanitarias
# unidades_sanitarias <- read_csv('coordenadas_unidades_sanitarias.csv')
# unidades_sanitarias <- data.frame(unidades_sanitarias)
# 
# # Define function for converting UTM to lat lon
# # (not currently vectorized, need to run loop)
# # convert_ll<-function(x){
# #   z <- as.numeric(gsub('\"', '', unlist(strsplit(x, '<b0>|\''))))
# #   as.numeric(z[1] + (z[2]/60) + (z[3]/3600))
# # } 
# convert_ll <- function(x){
#   z <- unlist(strsplit(x, '°|\'|"'))
#   as.numeric(z[1]) + (as.numeric(z[2])/60) + (as.numeric(z[3])/3600)
# }
# 
# # Convert the coordinates of health posts to lat long
# unidades_sanitarias$lon <-
#   unidades_sanitarias$x <-
#   unidades_sanitarias$y <- NA
# for (i in 1:nrow(unidades_sanitarias)){
#   unidades_sanitarias$x[i] <-
#   unidades_sanitarias$lon[i] <-
#   unidades_sanitarias$lng[i] <- 
#   as.numeric(convert_ll(unidades_sanitarias$lng[i]))
#   unidades_sanitarias$y[i] <-
#   unidades_sanitarias$lat[i] <-
#   as.numeric(convert_ll(unidades_sanitarias$lat[i]) * -1)
# }
# 
# # Make it all numeric
# for (j in 2:ncol(unidades_sanitarias)){
#   unidades_sanitarias[,j] <-
#     as.numeric(unidades_sanitarias[,j])
# }
# 
# # Make spatial
# coordinates(unidades_sanitarias) <- ~x+y
# proj4string(unidades_sanitarias) <- 
#   CRS("+proj=longlat +ellps=WGS84 +datum=WGS84")

# Alternative unidades sanitarias (sent 2016-10-05)
us <- readxl::read_excel('coordenadas_utm.xlsx')
names(us) <- c('unidad_sanitaria',
               'location')

# Create x and y
us$x <- us$y <- NA
us$x <- unlist(lapply(strsplit(us$location, split = '/'), function(x){x[1]}))
us$y <- unlist(lapply(strsplit(us$location, split = '/'), function(x){x[2]}))
us$x <- as.numeric(us$x)
us$y <- as.numeric(us$y)

# Create a UTM x and y
us$utm_x <- us$x
us$utm_y <- us$y

# Make spatial 
coordinates(us) <- ~x+y
# Assing projection
proj4string(us) <- CRS("+proj=utm +zone=36 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs")
# Convert to lat/lng
us <- spTransform(us,
              CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +towgs84=0,0,0"))

# Extract the coordinates
ll <- coordinates(us)
# Add back into the original dataframe
us$lng <- ll[,1]
us$lat <- ll[,2]
unidades_sanitarias <- us


# Read in tesfam
tesfam <- read.dta13('TESFAM_variables_selecion_02.dta')

# Read in coords
coords <- read_csv('Coordenadas.csv')
coords <- coords[!duplicated(coords$Family_id),]

# Join tesfam and coords
tesfam <- left_join(x = tesfam,
                    y = coords,
                    by = c('familynum' = 'Family_id')) %>%
  # filter(!duplicated(familynum)) %>%
  mutate(lon = LongUTM,
         lat = LatUTM,
         x = LongUTM,
         y = LatUTM)

# Make tesfam spatial
tesfam <- tesfam[!is.na(tesfam$x),]
coordinates(tesfam) <- ~x+y

# Make tesfam latlong
proj4string(tesfam) <- CRS("+proj=utm +zone=36 +south")
tesfam <- spTransform(tesfam,CRS("+proj=longlat +ellps=WGS84 +datum=WGS84"))

# Overwrite lat long
tesfam$lon <- coordinates(tesfam)[,1]
tesfam$lat <- coordinates(tesfam)[,2]

# Get distance to and name of nearest health center for each
# person in tesfam
tesfam$health_post <- NA
tesfam$distance <- NA

# Now calculate distance
distances <- 
  spDists(x = tesfam, 
        y = unidades_sanitarias,
        longlat = TRUE,
        diagonal = FALSE)

# Add distances to coordenadas dataframe
tesfam$distance <- 
  apply(distances, 1, function(x){x[which.min(x)]})

tesfam$distance_to_manhica_health_post <-
    apply(distances, 1, function(x){x[which.min(x)]})


# Get nearest center
tesfam$health_post <- 
  apply(distances,
        1, function(x){unidades_sanitarias$unidad_sanitaria[which.min(x)]})


# Get mozambique shapefile
moz <- getData('GADM', country = 'MOZ', level = 2)
moz3 <- getData('GADM', country = 'MOZ', level = 3)

# Subset to manhica
man <- moz[moz@data$NAME_2 == 'Manhiça',]
man3 <- moz3[moz3@data$NAME_2 == 'Manhiça',]

# Fortify
moz3_fortified <- fortify(moz3, region = 'NAME_3')
man3_fortified <- fortify(man3, region = 'NAME_3')


# Create a color based on testgroup
tesfam$color <-
  ifelse(tesfam$testgroup == 'HBT', 'blue',
         ifelse(tesfam$testgroup == 'VCT', 'darkorange',
                ifelse(tesfam$testgroup == "PICT", 'darkgreen',
                       NA)))

# Create a shape based on attrition
tesfam$shape <- 
  ifelse(tesfam$abandono_3mo == 1, 17,
         ifelse(tesfam$abandono_3mo == 0, 16, NA))
```

# General locations

```{r}
# Plot using base map
plot(man3, col = 'grey', border = 'white')
# People points
points(tesfam, 
       col = adjustcolor(tesfam$color, alpha.f = 0.7), 
       pch = tesfam$shape, 
       cex = 0.2)
# Health center points
points(unidades_sanitarias,
       col = adjustcolor('darkred', alpha.f = 0.7),
       pch = 1)
# Add legend
legend('topleft',
       col = c('blue', 'darkorange', 'darkgreen'),
       legend = c('HBT', 'VCT', 'PICT'),
       title = 'Testing venue',
       pch = 1)
legend('bottomright',
       pch = c(17, 16),
       legend = c('Lost to follow-up', 'Followed-up'),
       title = 'Linkage at 3 months')
legend('topright',
       pch = 1,
       col = adjustcolor('darkred', alpha.f = 0.8),
       legend = 'Health centers')
title(main = 'HIV cascade for TESFAM cohort at 3 months')


```


```{r, fig.width = 8}

cols <- c('blue', 'darkorange', 'darkgreen')
g1 <- 
  ggplot() +
coord_map() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y =lat, group = group), 
               fill = 'grey', color = 'white') +
  geom_point(data = tesfam@data %>% 
               mutate(`Follow up` = ifelse(abandono_3mo == 1, 'Lost',
                                                                'Not lost')),
              aes(x = lon, y = lat,
                  color = testgroup,
                  pch = `Follow up`),
             size = 0.5) +
  scale_color_manual(name = 'Testing venue',
                     values = cols) +
  theme_fivethirtyeight() +
  xlab('Longitude') +
  ylab('Latitude') +
  labs(title = 'Spatial distribution',
       subtitle = '3 months follow-up')

# Same as above but at 6 months

cols <- c('blue', 'darkorange', 'darkgreen')
g2 <- 
  ggplot() +
coord_map() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y =lat, group = group), 
               fill = 'grey', color = 'white') +
  geom_point(data = tesfam@data %>% 
               mutate(`Follow up` = ifelse(abandono_6mo == 1, 'Lost',
                                                                'Not lost')),
              aes(x = lon, y = lat,
                  color = testgroup,
                  pch = `Follow up`),
             size = 0.5) +
  scale_color_manual(name = 'Testing venue',
                     values = cols) +
  theme_fivethirtyeight() +
  xlab('Longitude') +
  ylab('Latitude') +
  labs(title = 'Spatial distribution',
       subtitle = '6 months follow-up')
Rmisc::multiplot(g1, g2, cols = 2)
```


# Distance to nearest health post


## Patients 


The below map shows health posts (red) and patients (blue). The shading of the blue indicates the distance to the nearest health post.  

This map is interactive. Create a box on the map to zoom in. Double-click to zoom out. Click on the legend to remove or add points. Mouse over the points to get more details.


```{r, eval = FALSE}
# Distance to health post
g <- 
  ggplot() +
coord_map() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y =lat, group = group), 
               fill = 'grey', color = 'white') +
  geom_point(data = tesfam@data %>% 
               mutate(`Follow up` = ifelse(abandono_6mo == 1, 'Lost',
                                                                'Not lost'),
                      `Distance to health post` = distance),
              aes(x = lon, y = lat,
                  color = `Distance to health post`,
                  pch = `Follow up`),
             size = 0.5) +
    geom_point(data = unidades_sanitarias@data,
               aes(x = lon, y = lat),
             color = 'red') +
  # scale_color_gradientn(colours = terrain.colors(10)) +
  theme_fivethirtyeight(base_size = 12) +
  xlab('Longitude') +
  ylab('Latitude') +
  labs(title = 'Distance to nearest health post',
       subtitle = '(The red dots are the health facilities)')
ggplotly(g)
```


## All locations

```{r}
# Raster surface of distance to nearest health post

# Create a grid
xs <- bbox(man3)[1,]
ys <- bbox(man3)[2,]
df_grid <-
  expand.grid(x = seq(min(xs), max(xs), length = 1000),
              y = seq(min(ys), max(ys), length = 1000))
df_grid$longitude <- df_grid$x
df_grid$latitude <- df_grid$y

# Make spatial
df_grid_spatial <- df_grid
coordinates(df_grid_spatial) <- ~x+y
proj4string(df_grid_spatial) <- proj4string(unidades_sanitarias)

# Get distances to nearest health post
distances <- 
  spDists(x = df_grid_spatial, 
        y = unidades_sanitarias,
        longlat = TRUE,
        diagonal = FALSE)

# Add distances to coordenadas dataframe
df_grid_spatial$distance <- 
  apply(distances, 1, function(x){x[which.min(x)]})

# Get nearest center
df_grid_spatial$health_post <- 
  apply(distances,
        1, function(x){unidades_sanitarias$unidad_sanitaria[which.min(x)]})

# Convert or raster
temp <- df_grid_spatial@data %>% arrange(longitude, latitude)
r <- rasterFromXYZ(temp[,c('longitude', 'latitude', 'distance')])

# Keep only those points in our area
proj4string(df_grid_spatial) <- proj4string(man3)
x <- over(df_grid_spatial, polygons(man3))
df_grid_small <- df_grid_spatial[!is.na(x),]

# Convert our subset data to raster
temp <- df_grid_small@data %>% arrange(longitude, latitude)
r <- rasterFromXYZ(temp[,c('longitude', 'latitude', 'distance')])
proj4string(r) <- proj4string(man3)
```

### Catchment areas

Having calculated the distances to all areas, we can examine "catchment areas". This is useful to analyze health post burden, as well as mismatching.

The below is a map of the health posts only.

```{r}
# Get a label column in unidades_sanitarias
unidades_sanitarias@data$label <-
  Hmisc::capitalize(trimws(gsub('Centro de saude de', '', unidades_sanitarias@data$unidad_sanitaria), 'both'))

library(ggrepel)
ggplot() +
  xlab('Longitude') +
  ylab('Latitude') +
  theme_bw() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y = lat, group = group),
               fill = 'grey', color = 'darkgrey') +
  geom_point(data = unidades_sanitarias@data,
             aes(x = lng, y = lat)) +
  geom_label_repel(data = unidades_sanitarias@data,
             aes(x = lng, y = lat,
                 label = unidades_sanitarias@data$label),
             fill = 'darkgreen',
             alpha = 0.5,
             fontface = 'bold', color = 'white',
             box.padding = unit(0.25, 'lines'),
             point.padding = unit(0.5, 'lines')) +
  coord_map()

```

The below shows the catchment breakdowns.

```{r}
catchment_data <- df_grid_small@data
catchment_data <- catchment_data %>%
  left_join(unidades_sanitarias@data %>%
              dplyr::select(label, unidad_sanitaria),
            by = c('health_post' = 'unidad_sanitaria'))
cols <- colorRampPalette(brewer.pal(9, 'Spectral'))(length(unique(df_grid_small@data$health_post)))
ggplot() +
  geom_point(data = catchment_data,
       aes(x = longitude,
           y = latitude,
           color = label)) +
  scale_colour_manual(name = 'Health post',
                    values = cols) +
  xlab('Longitude') +
  ylab('Latitude') +
  theme_bw() +
  geom_polygon(data = man3_fortified,
               aes(x = long, y = lat, group = group),
               fill = NA, color = 'black') +
  geom_point(data = unidades_sanitarias@data,
             aes(x = lng, y = lat)) +
  coord_map()
```

We can also visual the number of study participants who fall into each catchment area:

```{r}
temp <- tesfam@data %>%
  group_by(health_post) %>%
  tally 
ggplot(data = temp,
       aes(x = health_post,
           y = n)) +
  geom_bar(stat = 'identity') +
  xlab('Health post') +
  ylab('Patients') +
  ggtitle('Catchment areas of TESFAM study participants') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Of equal (if not greater) interest are the follow-up outcomes of those patients:

```{r}
temp <- tesfam@data %>%
  group_by(health_post) %>%
  summarise(total = n(),
            lost_3 = sum(abandono_3mo),
            lost_6 = sum(abandono_6mo)) %>%
  mutate(p_3 = lost_3 / total * 100,
         p_6 = lost_6 / total * 100) %>%
  dplyr::select(-total, -lost_3, -lost_6)

# Gather into long format
temp <- temp %>%
  tidyr::gather(key, value, p_3:p_6)

# Clean up
temp$key <- gsub('p_', '', temp$key)
temp$key <- paste0('Lost at ', temp$key, ' months')
# Plot
ggplot(data = temp,
       aes(x = health_post,
           y = value,
           group = key,
           fill = key)) +
  geom_bar(stat = 'identity', 
           position = 'dodge') +
  xlab('Health post') +
  ylab('Percentage') +
  ggtitle('Percentage lost to follow-up by catchment area') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Distances

To make our work more generalizable, we can also examine the distance to the nearest health post for _all_ locations, regardless of whether a patient lives there or not. The below maps attempt to show this concept.

```{r}
# Visualize
plot(r, main = 'Kilometers to nearest health post (shading)')
plot(man3)
contour(r, add = TRUE, col = adjustcolor('black', alpha.f = 0.3),
        main = 'Kilometers to nearest health post (contour)')
# levelplot(r, contour = FALSE, par.settings = RdBuTheme,
#           main = 'Kilometers to nearest health post (shading + contour)')
vectorplot(r, par.settings = RdBuTheme(),
           lwd.arrows = 0.3,
           col.arrows = adjustcolor('black', alpha.f = 0.2),
           main = 'Kilometers to nearest health post (vector + shading)')
```


### "Acceptably close" residents

Distance to health post is a continuous variable. However, we might deem binning it or making it binary a worthy cause in the pursuit of simplicity, modeling, etc.

The below chart shows the percentage of TESFAM patients who are deemed to be "acceptably close" to a health post, as a function of how we define "acceptable".

```{r}
df <- data.frame(distance = seq(0, 15, length = 100))
df$patients <- NA
for (i in 1:nrow(df)){
  df$patients[i] <-
    length(which(tesfam$distance <= df$distance[i]))
}
df$p <- df$patients / nrow(tesfam) * 100

ggplot(data = df,
       aes(x = distance, y = p)) +
  geom_area(fill = 'darkred', alpha = 0.6) +
  xlab('Distance') +
  ylab('Percentage') +
  ggtitle('Percentage of patients "acceptably close" to health post')
```


### Person-kilometers attributable to each health post

We can calculate the total number of kilometers needed to be traveled by each TESFAM participant in order to reach the nearest health post (see below map).

```{r}
ggplot() +
  geom_polygon(data = man3_fortified,
       aes(x = long,
           y = lat,
           group = group)) +
  coord_map() +
  geom_point(data = tesfam@data,
             aes(size = distance,
                 color = health_post,
                 x = lon, 
                 y = lat),
             alpha = 0.3) +
  xlab('Longitude') +
  ylab('Latitude')
```

We can then aggregate at the health post level to get the person-kilometers attributable to each post. By the same token, we can also just get average distance for patients for each catchment area:

```{r}
temp <- tesfam@data %>%
  group_by(health_post) %>%
  summarise(total_distance = sum(distance),
            average_distance = mean(distance),
            patients = n())

ggplot(data = temp,
       aes(x = health_post,
           y = average_distance)) +
  geom_bar(stat = 'identity', fill = 'darkred', alpha = 0.6) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  xlab('Health post') +
  ylab('Average kilometers') +
  ggtitle('Average distance from post to patients for each catchment area')
```

# Distance-weighted HIV prevalence score

Requires full HIV prevalence data.


# Analysis

Association between distance to center and likelihood of being lost to follow-up. 

```{r}
# Logistic regression model
fit <- glm(abandono_6mo ~ distance, 
           data = tesfam@data,
           family = binomial('logit'))
ors <- exp(cbind(OR = coef(fit), confint(fit))) %>%
  data.frame
```

Using a simple logistic regression model, we estimate that for every 1 kilometer further from a health post, the odds of being lost to follow-up at 6 months increases by `r round((ors$OR[2] - 1) * 100, digits = 2)`% (OR of `r ors$OR[2]`, 95% confidence interval of `r ors$X2.5..[2]` to `r ors$X97.5..[2]`). Our fitted model can be visualized like this.

```{r}
fake <- data.frame(distance = seq(0, 25, length = 100))
predictions <- predict(fit, fake, type = 'link', se = TRUE)
fake$predicted <- plogis(predictions$fit)
fake$lwr <- plogis(predictions$fit - (1.96 * predictions$se.fit))
fake$upr <- plogis(predictions$fit + (1.96 * predictions$se.fit))

# Gather
fake_gathered <- tidyr::gather(data = fake,
                               key, 
                               value, 
                               predicted:upr)

ggplot(data = fake) +
  geom_linerange(aes(x = distance,
                     ymax = upr,
                     ymin = lwr),
                 alpha = 0.6) +
  geom_line(aes(x = distance, y = predicted),
            color = 'red') +
  labs(title = 'Distance matters?',
       subtitle = 'Association of distance to health post and getting lost') +
  theme_economist() +
    xlab('Kilometers to health post') +
  ylab('Likelihood of being lost to follow-up at 6 mo') 
```

# Appendix

## Fancy interactive satellite map

The blue markers are health posts.

```{r}
library(leaflet)
library(RColorBrewer)

colspal <- brewer.pal(3, 'Spectral')
cols <- colspal[as.numeric(factor(tesfam$testgroup))]

# Subset data to only include those that got lost
lost <- data.frame(tesfam) %>% filter(abandono_3mo == 1)
not_lost <- data.frame(tesfam) %>% filter(abandono_3mo == 0)

# Get colors
lost_cols <- colspal[as.numeric(factor(lost$testgroup))]
not_lost_cols <- colspal[as.numeric(factor(not_lost$testgroup))]


leaflet() %>%
  # addProviderTiles('Stamen.Watercolor') %>%
  addProviderTiles("Esri.WorldImagery") %>%
  addCircleMarkers(lng = lost$lon,
                  lat = lost$lat,
                  color = lost_cols,
                  fillColor = lost_cols,
                  radius = 2.5,
                  opacity = 0,
                  fillOpacity = 0.5,
                  popup = paste0('Study number: ', lost$ssid, '\n',
                                 'Group: ', lost$testgroup, '\n',
                                 '3 month followup: ',
                                 ifelse(lost$abandono_3mo == 1, 'Lost',
                                        'Not lost'))) %>%
      addLegend("bottomright", colors= colspal,
                labels=c('HBT', 'VCT', 'PICT'), title="Study arm") %>%
    addCircleMarkers(lng = not_lost$lon,
                  lat = not_lost$lat,
                  color = not_lost_cols,
                  fillColor = not_lost_cols,
                  radius = 5,
                  opacity = 0,
                  fillOpacity = 1,
                  popup = paste0('Study number: ', not_lost$ssid, '\n',
                                 'Group: ', not_lost$testgroup, '\n',
                                 '3 month followup: ', 
                                 ifelse(not_lost$abandono_3mo == 1, 'Lost',
                                        'Not not_lost'))) %>% #,
                  # clusterOptions = markerClusterOptions()) 
  addMarkers(lng = unidades_sanitarias@data$lng,
             lat = unidades_sanitarias@data$lat,
             popup = unidades_sanitarias@data$name)
```


## Fancy interactive road map

The blue markers are health posts.

```{r}
library(leaflet)
library(RColorBrewer)
colspal <- brewer.pal(3, 'Spectral')
cols <- colspal[as.numeric(factor(tesfam$testgroup))]

# Subset data to only include those that got lost
lost <- data.frame(tesfam) %>% filter(abandono_3mo == 1)
not_lost <- data.frame(tesfam) %>% filter(abandono_3mo == 0)

# Get colors
lost_cols <- colspal[as.numeric(factor(lost$testgroup))]
not_lost_cols <- colspal[as.numeric(factor(not_lost$testgroup))]


leaflet() %>%
  # addProviderTiles('Stamen.Watercolor') %>%
  # addProviderTiles("Esri.WorldImagery") %>%
  addProviderTiles('OpenStreetMap.BlackAndWhite') %>%
  addCircleMarkers(lng = lost$lon,
                  lat = lost$lat,
                  color = lost_cols,
                  fillColor = lost_cols,
                  radius = 2.5,
                  opacity = 0,
                  fillOpacity = 0.5,
                  popup = paste0('Study number: ', lost$ssid, '\n',
                                 'Group: ', lost$testgroup, '\n',
                                 '3 month followup: ',
                                 ifelse(lost$abandono_3mo == 1, 'Lost',
                                        'Not lost'))) %>%
      addLegend("bottomright", colors= colspal,
                labels=c('HBT', 'VCT', 'PICT'), title="Study arm") %>%
    addCircleMarkers(lng = not_lost$lon,
                  lat = not_lost$lat,
                  color = not_lost_cols,
                  fillColor = not_lost_cols,
                  radius = 5,
                  opacity = 0,
                  fillOpacity = 1,
                  popup = paste0('Study number: ', not_lost$ssid, '\n',
                                 'Group: ', not_lost$testgroup, '\n',
                                 '3 month followup: ', 
                                 ifelse(not_lost$abandono_3mo == 1, 'Lost',
                                        'Not not_lost'))) %>%#,
                  # clusterOptions = markerClusterOptions()) 
    addMarkers(lng = unidades_sanitarias@data$lng,
             lat = unidades_sanitarias@data$lat,
             popup = unidades_sanitarias@data$name)

```


